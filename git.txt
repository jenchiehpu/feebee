分支概念：
目前在master，做了一個branch A，那麼A就是Master的branch。
目前在A，做了一個branch A1，那麼A1就是A的branch。
在A可以做branch A1,A2,A3...，這些都是A的branch。

是否能看到檔案的權限：
無論在master, A, A1都可以touch files，例如新建立test.md，但只要沒有去$git add，任一branch都可以看到test.md。若是在A下指令$git add和$git commit，則master看不到test.md，但A1, A2, A3...都可以下指令$ls -al 看到test.md這個檔案。
要注意的是，最終是以位於哪個branch下指令commit，判斷哪個brnach才能看到這檔案。
如果位在master 下指令$gir add  test.md，切換到branch A，
$git checkout A
$git commit test.md -touch a new file test.md”
$ls -al
那麼會看到test.md。
但是在master執行指令
$ls -al
則看不到A

何謂版本控制
集中式：類似雲端，在雲端上修改，每個參與者都可以看到修改後的結果，類似google文件&試算表，缺點是只要無法連上網路，即無法做任何修改，我們可能會想著不如在自己本機端先改完後，再上傳，但集中式不允許此方式，一定得在雲端修改，但本機端應該不需要準備備份資料的空間

分散式
每個參與者從雲端上copy一份程式碼，開始去更動，聽起來的壞處是，每個參與者都得準備空間儲存目標檔案。但好處是彼此可以獨立作業，不需要網路也能做CRUD這些事。假設只有一個參與者，就是copy雲端的資料後，在本機端新增修改後，上傳雲端，為最新的版本。假設是兩位參與者A、B和目標檔案，

雲端版本（1.0.0）
A下載後更改from(1.0.0)->(1.0.1)
上傳雲端，(1.0.1)
B下載更改(1.0.1)->(1.0.2)
上傳雲端(1.0.2)

這流程沒什麼問題
但要是A、B同時下載
雲端版本 (1.0.0)
A下載(1.0.0)
B下載(1.0.0)
A和B都是下載同一版本
A修改後上傳雲端(1.0.0)->(1.0.1)
雲端版本(1.0.1)
這時候雲端版本是1.0.1
B是用1.0.0版本修改 要上傳發現出問題
B會覆蓋A的檔案。
因此B得下載雲端最新檔案，(即A的檔案)
和自己的對照後沒有衝突，合併A和B的檔案
上傳至雲端(1.0.2)
這就是分散式的多人控制的原理

理解這概念就可以去理解，只有單一個使用者，不需要上傳雲端，在自己本機透過git備份，就是不斷的下指令commit設定儲存點，出問題可以回到有commit的儲存點。



$git checkout -b [branch_name]
$git branch -d [branch_name]

 


